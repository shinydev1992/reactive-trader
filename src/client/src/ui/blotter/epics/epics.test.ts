import { ActionsObservable } from 'redux-observable'
import { createTestScheduler, fromMarbles, mockLifetimeAction$ } from 'rt-testing'
import { blotterServiceEpic } from './epics'
import { BlotterActions } from '../actions'
import { ServiceStubWithLoadBalancer } from 'rt-system'
import { fromTradeActionsToMarbles, toRawTradeUpdate } from '../testing'
import { Observable, of } from 'rxjs'
import { Direction } from 'rt-types'
// import { ConnectionActions } from 'rt-actions'
import { MockScheduler } from 'rt-testing'

const st = {
  IsStateOfTheWorld: true,
  IsStale: false,
  Trades: [
    {
      TradeId: 0,
      CurrencyPair: 'USD/EUP',
      TraderName: 'bob',
      Notional: 100,
      DealtCurrency: 'USD',
      Direction: Direction.Buy,
      Status: 'PENDING',
      SpotRate: 100,
      TradeDate: new Date().toString(),
      ValueDate: new Date().toString(),
    },
  ],
}
const MockServiceClient = jest.fn<ServiceStubWithLoadBalancer>(
  (getResponses: (service: string, operationName: string, request: any) => Observable<any>) => ({
    createStreamOperation: jest.fn((s: string, o: string, r: any) => getResponses(s, o, r)),
  }),
)

describe('blotterServiceEpic', () => {
  it('should ignore any action when there is no connection and subscription', () => {
    const randomAction = 'randomAction'
    const actionLifetime = '-a-b---'
    const expectLifetime = ''

    const scheduler = new MockScheduler()
    scheduler.run(({ cold, expectObservable, flush }) => {
      const actionReference = { a: { type: `${randomAction}1` }, b: { type: `${randomAction}2` } }
      const loadBalancedServiceStub = new MockServiceClient(() => of(st))
      const action$ = cold(actionLifetime, actionReference)
      // act
      const epics$ = blotterServiceEpic(ActionsObservable.from(action$, scheduler), undefined, {
        loadBalancedServiceStub,
      })
      expectObservable(epics$).toBe(expectLifetime)
    })
  })

  it('returns an observable that contains new trade actions for incoming trades', () => {
    const scheduler = createTestScheduler()
    scheduler.run(helpers => {
      // scenario
      const lifetimeAct1 = BlotterActions.subscribeToBlotterAction
      const lifetimeAct = '--C--1|' // See AppLifetimeEvent enum
      const tradeStream = '     --0--1----2' // trade IDs (generated as raw trade objects)
      const eeeexpected = '-------0--1----2' // trade IDs (generated by the epic as actions with trade payloads)

      // arrange
      const { cold, expectObservable } = helpers
      const loadBalancedServiceStub = new MockServiceClient(() => fromMarbles(toRawTradeUpdate, cold, tradeStream))
      const action$ = mockLifetimeAction$(cold(lifetimeAct), lifetimeAct1)

      // act
      const epic = blotterServiceEpic(ActionsObservable.from(action$, scheduler), undefined, {
        loadBalancedServiceStub,
      })

      // assert
      expect(loadBalancedServiceStub.createStreamOperation).toHaveBeenCalledTimes(1)
      expect(loadBalancedServiceStub.createStreamOperation).toHaveBeenCalledWith('blotter', 'getTradesStream', {})
      expectObservable(fromTradeActionsToMarbles(epic)).toBe(eeeexpected)
    })
  })

  it('returns an observable that stops generating trade actions when the application disconnects', () => {
    const scheduler = createTestScheduler()
    scheduler.run(helpers => {
      // scenario
      const lifetimeAct1 = BlotterActions.subscribeToBlotterAction
      const lifetimeAct = '--C--1-------D' // See AppLifetimeEvent enum
      const tradeStream = '     --0--1----2----3---4' // trade IDs (generated as raw trade objects)
      const eeeexpected = '-------0--1----2---------' // trade IDs (generated by the epic as actions with trade payloads)
      // NOTE: Although trade ID #2 is actually unexpected in the output, because it's after 'D', there are some race conditions due to the way the test scheduler works that we'll just accept for now.

      // arrange
      const { cold, expectObservable } = helpers
      const loadBalancedServiceStub = new MockServiceClient(() => fromMarbles(toRawTradeUpdate, cold, tradeStream))
      const action$ = mockLifetimeAction$(cold(lifetimeAct), lifetimeAct1)

      // act
      const epic = blotterServiceEpic(ActionsObservable.from(action$, scheduler), undefined, {
        loadBalancedServiceStub,
      })

      // assert
      expect(loadBalancedServiceStub.createStreamOperation).toHaveBeenCalledTimes(1)
      expect(loadBalancedServiceStub.createStreamOperation).toHaveBeenCalledWith('blotter', 'getTradesStream', {})
      expectObservable(fromTradeActionsToMarbles(epic)).toBe(eeeexpected)
    })
  })
})
